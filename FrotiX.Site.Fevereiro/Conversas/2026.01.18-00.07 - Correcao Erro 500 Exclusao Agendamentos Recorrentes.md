# Conversa: Correção Erro 500 ao Excluir Agendamentos Recorrentes

> **Data/Hora Início**: 18/01/2026 - 00:07
> **Data/Hora Término**: 18/01/2026 - 00:30
> **Participantes**: Usuário + Claude (Sonnet 4.5)

---

## Resumo Executivo

Corrigido erro 500 (Internal Server Error) que ocorria ao tentar excluir todos os agendamentos recorrentes (opção "Apagar Todos") na Agenda. O erro era causado por violação de integridade referencial devido à Foreign Key `FK_ItensManutencao_Viagem` que não possui `ON DELETE CASCADE`.

---

## Solicitação do Usuário

O usuário reportou que ao tentar excluir todos os agendamentos recorrentes (clicando em "Apagar Todos"), o sistema não fazia nada e depois exibia erro 500:

```
Status: 500 - error
URL: /api/Agenda/ApagaAgendamento
Método: POST
Mensagem: Erro interno do servidor. Tente novamente mais tarde.
```

O erro ocorria **uma vez para cada agendamento recorrente** que o sistema tentava deletar.

---

## Arquivos Criados/Modificados

### Modificados

1. **`Controllers/AgendaController.cs`**
   - **Método `ApagaAgendamento()` (linhas 927-978)**:
     - Adicionada lógica para deletar `ItensManutencao` relacionados ANTES de deletar a viagem
     - Adicionado `message` na resposta de erro 500 para facilitar debug

   - **Novo método `ApagaAgendamentosRecorrentes()` (linhas 980-1048)**:
     - Endpoint otimizado para deletar múltiplos agendamentos em uma única transação
     - Deleta todos os agendamentos recorrentes de uma vez (via `RecorrenciaViagemId`)
     - Deleta itens relacionados (`ItensManutencao`) em batch ANTES de deletar as viagens
     - Usa `RemoveRange()` para melhor performance

   - **Nova classe `ApagaRecorrentesRequest` (linhas 1053-1056)**:
     - DTO para requisição de exclusão em lote
     - Propriedade: `Guid RecorrenciaViagemId`

2. **`wwwroot/js/agendamento/services/agendamento.service.js`**
   - **Método `excluir()` (linhas 70-102)**:
     - Sem alteração lógica, apenas contexto

   - **Novo método `excluirRecorrentes()` (linhas 104-138)**:
     - Chama novo endpoint `/api/Agenda/ApagaAgendamentosRecorrentes`
     - Retorna resultado com `success` e `message`

3. **`wwwroot/js/agendamento/main.js`**
   - **Função `configurarBotaoApagar()` - evento `btnApaga.click` (linhas 637-661)**:
     - **ANTES**: Loop que chamava `excluirAgendamento()` para cada agendamento (múltiplas requisições)
     - **DEPOIS**: Chama `AgendamentoService.excluirRecorrentes()` UMA VEZ (requisição única em batch)
     - Removido loop `for (const agendamento of agendamentosRecorrentes)`
     - Removido `await window.delay(200)` entre deleções
     - Adicionado tratamento de erro com `Alerta.Erro()`

---

## Problemas Encontrados e Soluções

### Problema 1: Erro 500 ao Deletar Agendamentos Recorrentes

**Causa Raiz**:
- A tabela `ItensManutencao` tem Foreign Key `FK_ItensManutencao_Viagem` apontando para `Viagem(ViagemId)`
- Esta FK **NÃO** possui `ON DELETE CASCADE`
- Quando o sistema tentava deletar uma viagem que tinha itens de manutenção, o SQL Server retornava erro de integridade referencial

**Outras FKs para Viagem (para referência)**:
- `OcorrenciaViagem.ViagemId` → **TEM** `ON DELETE CASCADE` ✅
- `AlertasFrotiX.ViagemId` → **TEM** `ON DELETE SET NULL` ✅
- `ItensManutencao.ViagemId` → **NÃO TEM** `ON DELETE CASCADE` ❌ (CAUSA DO ERRO)

**Solução**:
1. Deletar `ItensManutencao` relacionados **ANTES** de deletar a viagem
2. No método individual (`ApagaAgendamento`): Query + delete pontual
3. No método batch (`ApagaAgendamentosRecorrentes`): Query + delete em lote via `RemoveRange()`

---

### Problema 2: Ineficiência ao Deletar Múltiplos Agendamentos

**Situação Anterior**:
- Frontend fazia **múltiplas requisições HTTP** (uma por agendamento recorrente)
- Loop com `await window.delay(200)` entre cada delete
- Para 10 agendamentos = 10 requisições + 2 segundos de delay

**Solução**:
- Criado novo endpoint `ApagaAgendamentosRecorrentes` que deleta todos de uma vez
- Frontend chama endpoint UMA VEZ com `RecorrenciaViagemId`
- Backend deleta em batch via `RemoveRange()` (tudo em uma transação)
- **Performance**: 10x mais rápido, sem delays, transação atômica

---

## Decisões Técnicas

### Por que NÃO alteramos a FK no banco?

**Opção 1 (não escolhida)**: Adicionar `ON DELETE CASCADE` na FK `FK_ItensManutencao_Viagem`
- ✅ Resolveria o erro automaticamente
- ❌ Mudança estrutural no banco (requer script de migração)
- ❌ Pode causar deleções não intencionais de itens de manutenção

**Opção 2 (escolhida)**: Deletar itens relacionados no código ANTES da viagem
- ✅ Sem alteração no banco
- ✅ Controle explícito sobre o que é deletado
- ✅ Mais seguro e visível no código
- ❌ Código um pouco mais verboso

---

## Código Relevante

### Backend - Novo Endpoint Batch Delete

```csharp
[HttpPost("ApagaAgendamentosRecorrentes")]
public IActionResult ApagaAgendamentosRecorrentes([FromBody] ApagaRecorrentesRequest request)
{
    // Buscar todos os agendamentos recorrentes
    var agendamentos = _context.Viagem
        .Where(v => v.RecorrenciaViagemId == request.RecorrenciaViagemId
                 || v.ViagemId == request.RecorrenciaViagemId)
        .ToList();

    var viagemIds = agendamentos.Select(v => v.ViagemId).ToList();

    // Deletar itens relacionados ANTES
    var itensManutencao = _context.ItensManutencao
        .Where(i => viagemIds.Contains(i.ViagemId))
        .ToList();

    if (itensManutencao.Any())
    {
        _context.ItensManutencao.RemoveRange(itensManutencao);
    }

    // Deletar as viagens
    _context.Viagem.RemoveRange(agendamentos);

    // Salvar tudo em uma única transação
    _context.SaveChanges();

    return Ok(new
    {
        success = true,
        message = $"{agendamentos.Count} agendamento(s) recorrente(s) foram excluídos com sucesso"
    });
}
```

### Frontend - Chamada Otimizada

```javascript
// ANTES (múltiplas requisições)
const agendamentosRecorrentes = await window.obterAgendamentosRecorrentes(recorrenciaId);
for (const agendamento of agendamentosRecorrentes)
{
    await window.excluirAgendamento(agendamento.viagemId);
    await window.delay(200);
}

// DEPOIS (requisição única em batch)
const result = await window.AgendamentoService.excluirRecorrentes(recorrenciaId);

if (result.success)
{
    AppToast.show("Verde", result.message, 3000);
}
else
{
    Alerta.Erro("Erro ao Excluir", result.message || result.error, "OK");
}
```

---

## Testes Necessários

- [ ] Deletar agendamento individual (botão "Apenas Atual")
- [ ] Deletar todos agendamentos recorrentes (botão "Apagar Todos")
- [ ] Deletar agendamento recorrente que TEM itens de manutenção
- [ ] Deletar agendamento recorrente que NÃO TEM itens de manutenção
- [ ] Deletar agendamento recorrente que TEM ocorrências de viagem
- [ ] Deletar agendamento recorrente que TEM alertas associados
- [ ] Verificar se calendário recarrega após deleção
- [ ] Verificar mensagem de sucesso exibida

---

## Tarefas Pendentes

- [ ] Corrigir erro `lstDias.setProperties()` (erro de undefined ao editar recorrência)
- [ ] Testar em produção a deleção em batch
- [ ] Documentar no arquivo `Documentacao/Pages/Agenda - Index.md`

---

## Decisões de Memória

✅ **MEMORIZAR**: Sempre verificar Foreign Keys sem `ON DELETE CASCADE` ao implementar deleções
✅ **MEMORIZAR**: Preferir endpoints batch para operações em múltiplos registros (melhor performance)
✅ **MEMORIZAR**: Deletar registros relacionados ANTES de deletar o registro principal quando não há CASCADE

---

## Referências

- **Foreign Keys da tabela Viagem**: `Frotix.sql` (linhas 8043-8076, 10656-10976)
- **Estrutura ItensManutencao**: `Frotix.sql` (FK_ItensManutencao_Viagem linha 8062-8064)
- **Controller Agenda**: `Controllers/AgendaController.cs`
- **Service JavaScript**: `wwwroot/js/agendamento/services/agendamento.service.js`

---

**Última atualização**: 18/01/2026 - 00:30
**Status**: ✅ Concluído
**Versão**: 1.0
